/*
 *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.
 *
 *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Modifications copyright (C) 2017 Uber Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not
 *  use this file except in compliance with the License. A copy of the License is
 *  located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 *  or in the "license" file accompanying this file. This file is distributed on
 *  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *  express or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 */

package io.temporal.internal.csm;

import static io.temporal.internal.common.WorkflowExecutionUtils.getEventTypeForCommand;
import static io.temporal.internal.common.WorkflowExecutionUtils.isCommandEvent;

import io.temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.Command;
import io.temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.RecordMarkerCommandAttributes;
import io.temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;
import io.temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.StartTimerCommandAttributes;
import io.temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes;
import io.temporal.api.common.v1.Payloads;
import io.temporal.api.common.v1.WorkflowExecution;
import io.temporal.api.enums.v1.CommandType;
import io.temporal.api.enums.v1.EventType;
import io.temporal.api.failure.v1.Failure;
import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;
import io.temporal.api.history.v1.HistoryEvent;
import io.temporal.api.history.v1.MarkerRecordedEventAttributes;
import io.temporal.workflow.ChildWorkflowCancellationType;
import io.temporal.workflow.Functions;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Queue;
import java.util.Random;
import java.util.UUID;

public final class CommandsManager {

  private static final String MARKER_HEADER_KEY = "header";
  private static final String MARKER_DATA_KEY = "data";
  private static final String SIDE_EFFECT_MARKER_NAME = "SideEffect";

  /**
   * The eventId of the last event in the history which is expected to be startedEventId unless it
   * is replay from a JSON file.
   */
  private final long workflowTaskStartedEventId;

  /** The eventId of the started event of the last successfully executed workflow task. */
  private final long previousStartedEventId;

  private final CommandsManagerListener callbacks;

  private Functions.Proc1<NewCommand> sink;

  /**
   * currentRunId is used as seed by Workflow.newRandom and randomUUID. It allows to generate them
   * deterministically.
   */
  private String currentRunId;

  /** Used Workflow.newRandom and randomUUID together with currentRunId. */
  private long idCounter;

  private long currentTimeMillis = -1;

  private long replayTimeUpdatedAtMillis;

  private final Map<Long, CommandsBase> commands = new HashMap<>();

  /** Commands generated by the currently processed workflow task. */
  private final Queue<NewCommand> newCommands = new LinkedList<>();

  private List<NewCommand> preparedCommands;

  /** EventId of the last handled WorkflowTaskStartedEvent. */
  private long startedEventId;

  private long curentCommandId;

  public CommandsManager(
      long previousStartedEventId,
      long workflowTaskStartedEventId,
      CommandsManagerListener callbacks) {
    System.out.println("NEW " + this);
    this.callbacks = Objects.requireNonNull(callbacks);
    this.previousStartedEventId = previousStartedEventId;
    this.workflowTaskStartedEventId = workflowTaskStartedEventId;
    sink = (command) -> newCommands.add(command);
  }

  private void setStartedEventId(long startedEventId) {
    this.startedEventId = startedEventId;
    // Skip WorkflowTaskCompleted
    this.curentCommandId = startedEventId + 2;
  }

  public final void handleEvent(HistoryEvent event) {
    if (isCommandEvent(event)) {
      takeCommand(event);
      return;
    }
    Long initialCommandEventId = getInitialCommandEventId(event);
    CommandsBase c = commands.get(initialCommandEventId);
    if (c != null) {
      c.handleEvent(event);
      if (c.isFinalState()) {
        System.out.println("commands.remove " + initialCommandEventId);
        commands.remove(initialCommandEventId);
      }
    } else {
      handleNonStatefulEvent(event);
    }
  }

  private void handleNonStatefulEvent(HistoryEvent event) {
    switch (event.getEventType()) {
      case EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
        this.currentRunId =
            event.getWorkflowExecutionStartedEventAttributes().getOriginalExecutionRunId();
        callbacks.start(event);
        break;
      case EVENT_TYPE_WORKFLOW_TASK_SCHEDULED:
        WorkflowTaskCommands c =
            WorkflowTaskCommands.newInstance(
                workflowTaskStartedEventId, new WorkflowTaskCommandsListener());
        commands.put(event.getEventId(), c);
        break;
      case EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
        callbacks.signal(event);
        break;
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
        callbacks.cancel(event);
        break;
      case EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED:
      case EVENT_TYPE_ACTIVITY_TASK_SCHEDULED:
      case EVENT_TYPE_MARKER_RECORDED:
      case EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_TIMER_STARTED:
      case EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW:
      case EVENT_TYPE_WORKFLOW_EXECUTION_FAILED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED:
        throw new IllegalArgumentException("Unexpected :" + event);
        //        takeCommand(event);
        //        break;
      case UNRECOGNIZED:
        break;
      default:
        System.out.println("Skipping processing of " + event);
        // TODO(maxim)
    }
  }

  void setCurrentTimeMillis(long currentTimeMillis) {
    if (this.currentTimeMillis < currentTimeMillis) {
      this.currentTimeMillis = currentTimeMillis;
      this.replayTimeUpdatedAtMillis = System.currentTimeMillis();
    }
  }

  public long getLastStartedEventId() {
    return startedEventId;
  }

  public void takeCommand(HistoryEvent event) {
    System.out.println("TAKE COMMAND " + event.getEventType());

    NewCommand newCommand;
    while (true) {
      newCommand = newCommands.poll();
      if (newCommand == null) {
        throw new IllegalStateException("No command scheduled that corresponds to " + event);
      }
      Optional<Command> optionalCommand = newCommand.getCommand();
      if (optionalCommand.isPresent()) {
        break;
      }
    }
    if (event.getEventId() != curentCommandId) {
      throw new IllegalStateException(
          "Command eventId " + curentCommandId + " doesn't match eventId: " + event.getEventId());
    }
    Command command = newCommand.getCommand().get();
    validateCommand(command, event);
    newCommand.setMatchingEvent(event);
    newCommand.getCommands().handleEvent(event);
    commands.put(curentCommandId, newCommand.getCommands());
    System.out.println(
        "TAKE COMMAND put " + curentCommandId + ": " + newCommand.getCommand().get());

    System.out.println(" takeCommand commands.put " + curentCommandId + ", command=" + command);

    curentCommandId++;
  }

  private void validateCommand(Command command, HistoryEvent event) {
    if (!equals(command.getCommandType(), event.getEventType())) {
      throw new IllegalStateException(command + " doesn't match " + event);
    }
  }

  private boolean equals(CommandType commandType, EventType eventType) {
    return getEventTypeForCommand(commandType) == eventType;
  }

  public List<Command> takeCommands() {
    System.out.println("TAKE COMMANDS");
    List<Command> result = new ArrayList<>(preparedCommands.size());
    // Account for workflow task completed
    long commandEventId = startedEventId + 2;
    for (NewCommand newCommand : preparedCommands) {
      Optional<Command> command = newCommand.getCommand();
      if (!command.isPresent()) {
        throw new IllegalStateException("non present command");
      }
      result.add(command.get());
      System.out.println(
          "TAKE COMMANDS put " + commandEventId + ": " + newCommand.getCommand().get());
      commands.put(commandEventId, newCommand.getCommands());
      commandEventId++;
      newCommand.setInitialCommandEventId(commandEventId);
    }
    preparedCommands.clear();
    return result;
  }

  private void prepareCommands() {
    System.out.println("PREPARE COMMANDS");
    preparedCommands = new ArrayList<>(newCommands.size());
    // Account for workflow task completed
    long commandEventId = startedEventId + 2;
    while (true) {
      NewCommand newCommand = newCommands.poll();
      if (newCommand == null) {
        break;
      }
      Optional<Command> command = newCommand.getCommand();
      if (command.isPresent()) {
        preparedCommands.add(newCommand);
        newCommand.setMatchingEvent(null);
      }
    }
  }

  /**
   * @param attributes attributes used to schedule an activity
   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,
   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents
   * @return an instance of ActivityCommands
   */
  public ActivityCommands newActivity(
      ScheduleActivityTaskCommandAttributes attributes,
      Functions.Proc1<HistoryEvent> completionCallback) {
    return ActivityCommands.newInstance(attributes, completionCallback, sink);
  }

  /**
   * Creates a new timer state machine
   *
   * @param attributes timer command attributes
   * @param completionCallback invoked when timer fires or reports cancellation. One of
   *     TimerFiredEvent, TimerCanceledEvent.
   * @return cancellation callback that should be invoked to initiate timer cancellation
   */
  public Functions.Proc newTimer(
      StartTimerCommandAttributes attributes, Functions.Proc1<HistoryEvent> completionCallback) {
    System.out.println("newTimer");
    TimerCommands timer = TimerCommands.newInstance(attributes, completionCallback, sink);
    return () -> timer.cancel();
  }

  /**
   * Creates a new child state machine
   *
   * @param attributes child workflow start command attributes
   * @param startedCallback callback that is notified about child start
   * @param completionCallback invoked when child reports completion or failure. The following types
   *     of events can be passed to the callback: StartChildWorkflowExecutionFailedEvent,
   *     ChildWorkflowExecutionCompletedEvent, ChildWorkflowExecutionFailedEvent,
   *     ChildWorkflowExecutionTimedOutEvent, ChildWorkflowExecutionCanceledEvent,
   *     ChildWorkflowExecutionTerminatedEvent.
   * @return cancellation callback that should be invoked to cancel the child
   */
  public Functions.Proc1<ChildWorkflowCancellationType> newChildWorkflow(
      StartChildWorkflowExecutionCommandAttributes attributes,
      Functions.Proc1<WorkflowExecution> startedCallback,
      Functions.Proc1<HistoryEvent> completionCallback) {
    ChildWorkflowCommands child =
        ChildWorkflowCommands.newInstance(attributes, startedCallback, completionCallback, sink);
    return (cancellationType) -> {
      if (child.isCancellable()) {
        if (cancellationType == ChildWorkflowCancellationType.ABANDON) {
          notifyChildCancelled(attributes, completionCallback);
          return;
        }
        child.cancel();
      } else if (!child.isFinalState()) {
        if (cancellationType == ChildWorkflowCancellationType.ABANDON) {
          notifyChildCancelled(attributes, completionCallback);
          return;
        }
        newCancelExternal(
            RequestCancelExternalWorkflowExecutionCommandAttributes.newBuilder()
                .setWorkflowId(attributes.getWorkflowId())
                .setNamespace(attributes.getNamespace())
                .build(),
            (event) -> {
              if (cancellationType == ChildWorkflowCancellationType.WAIT_CANCELLATION_REQUESTED) {
                notifyChildCancelled(attributes, completionCallback);
              }
            });
        if (cancellationType == ChildWorkflowCancellationType.TRY_CANCEL) {
          notifyChildCancelled(attributes, completionCallback);
        }
      }
    };
  }

  private static void notifyChildCancelled(
      StartChildWorkflowExecutionCommandAttributes attributes,
      Functions.Proc1<HistoryEvent> completionCallback) {
    completionCallback.apply(
        HistoryEvent.newBuilder()
            .setEventType(EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED)
            .setChildWorkflowExecutionCanceledEventAttributes(
                ChildWorkflowExecutionCanceledEventAttributes.newBuilder()
                    .setWorkflowType(attributes.getWorkflowType())
                    .setNamespace(attributes.getNamespace())
                    .setWorkflowExecution(
                        WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId())))
            .build());
  }

  /**
   * @param attributes
   * @param completionCallback invoked when signal delivery completes of fails. The following types
   *     of events can be passed to the callback: ExternalWorkflowExecutionSignaledEvent,
   *     SignalExternalWorkflowExecutionFailedEvent>
   */
  public Functions.Proc newSignalExternal(
      SignalExternalWorkflowExecutionCommandAttributes attributes,
      Functions.Proc2<HistoryEvent, Boolean> completionCallback) {
    return SignalExternalCommands.newInstance(attributes, completionCallback, sink);
  }

  /**
   * @param attributes attributes to use to cancel external worklfow
   * @param completionCallback one of ExternalWorkflowExecutionCancelRequestedEvent,
   *     RequestCancelExternalWorkflowExecutionFailedEvent
   */
  public void newCancelExternal(
      RequestCancelExternalWorkflowExecutionCommandAttributes attributes,
      Functions.Proc1<HistoryEvent> completionCallback) {
    CancelExternalCommands.newInstance(attributes, completionCallback, sink);
  }

  public void newUpsertSearchAttributes(
      UpsertWorkflowSearchAttributesCommandAttributes attributes) {
    UpsertSearchAttributesCommands.newInstance(attributes, sink);
  }

  public void newCompleteWorkflow(Optional<Payloads> workflowOutput) {
    CompleteWorkflowCommands.newInstance(workflowOutput, sink);
  }

  public void newFailWorkflow(Failure failure) {
    FailWorkflowCommands.newInstance(failure, sink);
  }

  public void newCancelWorkflow() {
    CancelWorkflowCommands.newInstance(
        CancelWorkflowExecutionCommandAttributes.getDefaultInstance(), sink);
  }

  public void newContinueAsNewWorkflow(ContinueAsNewWorkflowExecutionCommandAttributes attributes) {
    ContinueAsNewWorkflowCommands.newInstance(attributes, sink);
  }

  private long getInitialCommandEventId(HistoryEvent event) {
    switch (event.getEventType()) {
      case EVENT_TYPE_ACTIVITY_TASK_STARTED:
        return event.getActivityTaskStartedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_COMPLETED:
        return event.getActivityTaskCompletedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_FAILED:
        return event.getActivityTaskFailedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT:
        return event.getActivityTaskTimedOutEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED:
        return event.getActivityTaskCancelRequestedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_REQUEST_CANCEL_ACTIVITY_TASK_FAILED:
        throw new IllegalArgumentException("Unexpected event type: " + event.getEventType());
      case EVENT_TYPE_ACTIVITY_TASK_CANCELED:
        return event.getActivityTaskCanceledEventAttributes().getScheduledEventId();
      case EVENT_TYPE_TIMER_FIRED:
        return event.getTimerFiredEventAttributes().getStartedEventId();
      case EVENT_TYPE_CANCEL_TIMER_FAILED:
        throw new IllegalArgumentException("Unexpected event type: " + event.getEventType());
      case EVENT_TYPE_TIMER_CANCELED:
        return event.getTimerCanceledEventAttributes().getStartedEventId();
      case EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
        return event
            .getRequestCancelExternalWorkflowExecutionFailedEventAttributes()
            .getInitiatedEventId();
      case EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
        return event
            .getExternalWorkflowExecutionCancelRequestedEventAttributes()
            .getInitiatedEventId();
      case EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED:
        return event.getStartChildWorkflowExecutionFailedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED:
        return event.getChildWorkflowExecutionStartedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED:
        return event.getChildWorkflowExecutionCompletedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED:
        return event.getChildWorkflowExecutionFailedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED:
        return event.getChildWorkflowExecutionCanceledEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT:
        return event.getChildWorkflowExecutionTimedOutEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED:
        return event.getChildWorkflowExecutionTerminatedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
        return event
            .getSignalExternalWorkflowExecutionFailedEventAttributes()
            .getInitiatedEventId();
      case EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED:
        return event.getExternalWorkflowExecutionSignaledEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_WORKFLOW_TASK_STARTED:
        return event.getWorkflowTaskStartedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_WORKFLOW_TASK_COMPLETED:
        return event.getWorkflowTaskCompletedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT:
        return event.getWorkflowTaskTimedOutEventAttributes().getScheduledEventId();
      case EVENT_TYPE_WORKFLOW_TASK_FAILED:
        return event.getWorkflowTaskFailedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_SCHEDULED:
      case EVENT_TYPE_TIMER_STARTED:
      case EVENT_TYPE_MARKER_RECORDED:
      case EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW:
      case EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED:
      case EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES:
      case EVENT_TYPE_WORKFLOW_TASK_SCHEDULED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_FAILED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED:
        return event.getEventId();
      case UNRECOGNIZED:
      case EVENT_TYPE_UNSPECIFIED:
        throw new IllegalArgumentException("Unexpected event type: " + event.getEventType());
    }
    throw new IllegalStateException("unreachable");
  }

  public boolean isReplaying() {
    boolean result = previousStartedEventId >= startedEventId;
    System.out.println(
        "isReplaying="
            + result
            + ", previousStartedEventId="
            + previousStartedEventId
            + ", startedEventId="
            + startedEventId);
    return result;
  }

  public long currentTimeMillis() {
    return currentTimeMillis;
  }

  public UUID randomUUID() {
    String runId = currentRunId;
    if (runId == null) {
      throw new Error("null currentRunId");
    }
    String id = runId + ":" + idCounter++;
    byte[] bytes = id.getBytes(StandardCharsets.UTF_8);
    return UUID.nameUUIDFromBytes(bytes);
  }

  public Random newRandom() {
    return new Random(randomUUID().getLeastSignificantBits());
  }

  public void sideEffect(
      Functions.Func<Optional<Payloads>> func,
      Functions.Proc2<Optional<Payloads>, RuntimeException> callback) {
    Optional<Payloads> result;
    RecordMarkerCommandAttributes markerAttributes;
    if (isReplaying()) {
      markerAttributes = RecordMarkerCommandAttributes.getDefaultInstance();
      result = null;
    } else {
      try {
        result = func.apply();
      } catch (RuntimeException e) {
        callback.apply(Optional.empty(), e);
        return;
      }
      Map<String, Payloads> details = new HashMap<>();
      if (result.isPresent()) {
        details.put(MARKER_DATA_KEY, result.get());
      }
      markerAttributes =
          RecordMarkerCommandAttributes.newBuilder()
              .setMarkerName(SIDE_EFFECT_MARKER_NAME)
              .putAllDetails(details)
              .build();
    }
    final Optional<Payloads> finalResult = result; // cannot reference result directly from lambda
    System.out.println("SideEffect called");
    MarkerCommands.newInstance(
        markerAttributes,
        (event -> {
          if (event == null) {
            callback.apply(finalResult, null);
          } else {
            MarkerRecordedEventAttributes attributes = event.getMarkerRecordedEventAttributes();
            if (!attributes.getMarkerName().equals(SIDE_EFFECT_MARKER_NAME)) {
              throw new IllegalStateException(
                  "Expected " + SIDE_EFFECT_MARKER_NAME + ", received: " + attributes);
            }
            Map<String, Payloads> map = attributes.getDetailsMap();
            Optional<Payloads> fromMaker = Optional.ofNullable(map.get(MARKER_DATA_KEY));
            callback.apply(fromMaker, null);
          }
        }),
        callbacks::eventLoop,
        sink);
  }

  /**
   * @param id mutable side effect id
   * @param func given the value from the last marker returns value to store. If result is empty
   *     nothing is recorded into the history.
   * @param callback used to report result or failure
   */
  public void mutableSideEffect(
      String id,
      Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,
      Functions.Proc2<Optional<Payloads>, RuntimeException> callback) {
    //    Optional<Payloads> result = mutableSideEffectResults.get(id);
    //    if (isReplaying()) {
    //      if (result == null || func.apply(Optional.empty()).isPresent()) {
    //
    //      }
    //
    //      MarkerCommands.newInstance(
    //              RecordMarkerCommandAttributes.getDefaultInstance(),
    //
    //    } else {
    //
    //    }
  }

  private class WorkflowTaskCommandsListener implements WorkflowTaskCommands.Listener {
    @Override
    public void workflowTaskStarted(long startedEventId, long currentTimeMillis) {
      setStartedEventId(startedEventId);
      CommandsManager.this.currentTimeMillis = currentTimeMillis;
      CommandsManager.this.callbacks.eventLoop();
      if (CommandsManager.this.workflowTaskStartedEventId == startedEventId) {
        prepareCommands();
      }
    }

    @Override
    public void updateRunId(String currentRunId) {
      CommandsManager.this.currentRunId = currentRunId;
    }
  }
}
