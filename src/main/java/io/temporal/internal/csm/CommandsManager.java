/*
 *  Copyright (C) 2020 Temporal Technologies, Inc. All Rights Reserved.
 *
 *  Copyright 2012-2016 Amazon.com, Inc. or its affiliates. All Rights Reserved.
 *
 *  Modifications copyright (C) 2017 Uber Technologies, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License"). You may not
 *  use this file except in compliance with the License. A copy of the License is
 *  located at
 *
 *  http://aws.amazon.com/apache2.0
 *
 *  or in the "license" file accompanying this file. This file is distributed on
 *  an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
 *  express or implied. See the License for the specific language governing
 *  permissions and limitations under the License.
 */

package io.temporal.internal.csm;

import static io.temporal.internal.common.WorkflowExecutionUtils.getEventTypeForCommand;
import static io.temporal.internal.common.WorkflowExecutionUtils.isCommandEvent;

import io.temporal.api.command.v1.CancelWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.Command;
import io.temporal.api.command.v1.ContinueAsNewWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.RequestCancelExternalWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.ScheduleActivityTaskCommandAttributes;
import io.temporal.api.command.v1.SignalExternalWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.StartChildWorkflowExecutionCommandAttributes;
import io.temporal.api.command.v1.StartTimerCommandAttributes;
import io.temporal.api.command.v1.UpsertWorkflowSearchAttributesCommandAttributes;
import io.temporal.api.common.v1.Payloads;
import io.temporal.api.common.v1.WorkflowExecution;
import io.temporal.api.enums.v1.CommandType;
import io.temporal.api.enums.v1.EventType;
import io.temporal.api.failure.v1.Failure;
import io.temporal.api.history.v1.ChildWorkflowExecutionCanceledEventAttributes;
import io.temporal.api.history.v1.HistoryEvent;
import io.temporal.workflow.ChildWorkflowCancellationType;
import io.temporal.workflow.Functions;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Queue;
import java.util.Random;
import java.util.UUID;

public final class CommandsManager {

  /**
   * The eventId of the last event in the history which is expected to be startedEventId unless it
   * is replay from a JSON file.
   */
  private final long workflowTaskStartedEventId;

  /** The eventId of the started event of the last successfully executed workflow task. */
  private final long previousStartedEventId;

  private final CommandsManagerListener callbacks;

  /** Callback to send new commands to. */
  private Functions.Proc1<NewCommand> sink;

  /**
   * currentRunId is used as seed by Workflow.newRandom and randomUUID. It allows to generate them
   * deterministically.
   */
  private String currentRunId;

  /** Used Workflow.newRandom and randomUUID together with currentRunId. */
  private long idCounter;

  private long currentTimeMillis = -1;

  private long replayTimeUpdatedAtMillis;

  private final Map<Long, CommandsBase> commands = new HashMap<>();

  /** Commands generated by the currently processed workflow task. */
  private final Queue<NewCommand> newCommands = new LinkedList<>();

  private List<NewCommand> preparedCommands;

  /** EventId of the last handled WorkflowTaskStartedEvent. */
  private long startedEventId;

  private long curentCommandId;

  public CommandsManager(
      long previousStartedEventId,
      long workflowTaskStartedEventId,
      CommandsManagerListener callbacks) {
    System.out.println("NEW " + this);
    this.callbacks = Objects.requireNonNull(callbacks);
    this.previousStartedEventId = previousStartedEventId;
    this.workflowTaskStartedEventId = workflowTaskStartedEventId;
    sink = (command) -> newCommands.add(command);
  }

  private void setStartedEventId(long startedEventId) {
    this.startedEventId = startedEventId;
    // Skip WorkflowTaskCompleted
    this.curentCommandId = startedEventId + 2;
  }

  public final void handleEvent(HistoryEvent event) {
    if (isCommandEvent(event)) {
      handleCommand(event);
      return;
    }
    Long initialCommandEventId = getInitialCommandEventId(event);
    CommandsBase c = commands.get(initialCommandEventId);
    if (c != null) {
      c.handleEvent(event);
      if (c.isFinalState()) {
        System.out.println("commands.remove " + initialCommandEventId);
        commands.remove(initialCommandEventId);
      }
    } else {
      handleNonStatefulEvent(event);
    }
  }

  private void handleNonStatefulEvent(HistoryEvent event) {
    switch (event.getEventType()) {
      case EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
        this.currentRunId =
            event.getWorkflowExecutionStartedEventAttributes().getOriginalExecutionRunId();
        callbacks.start(event);
        break;
      case EVENT_TYPE_WORKFLOW_TASK_SCHEDULED:
        WorkflowTaskCommands c =
            WorkflowTaskCommands.newInstance(
                workflowTaskStartedEventId, new WorkflowTaskCommandsListener());
        commands.put(event.getEventId(), c);
        break;
      case EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
        callbacks.signal(event);
        break;
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
        callbacks.cancel(event);
        break;
      case UNRECOGNIZED:
        break;
      default:
        throw new IllegalArgumentException("Unexpected event:" + event);
        // TODO(maxim)
    }
  }

  void setCurrentTimeMillis(long currentTimeMillis) {
    if (this.currentTimeMillis < currentTimeMillis) {
      this.currentTimeMillis = currentTimeMillis;
      this.replayTimeUpdatedAtMillis = System.currentTimeMillis();
    }
  }

  public long getLastStartedEventId() {
    return startedEventId;
  }

  /**
   * Handles command event
   *
   * @param event
   */
  public void handleCommand(HistoryEvent event) {
    System.out.println("HANDLE COMMAND " + event.getEventType());

    NewCommand newCommand;
    // skips cancelled commands
    while (true) {
      newCommand = newCommands.poll();
      if (newCommand == null) {
        throw new IllegalStateException("No command scheduled that corresponds to " + event);
      }
      // Note that event handling can cause a command cancellation in case
      // of some markers
      newCommand.handleEvent(event);
      if (!newCommand.isCanceled()) {
        break;
      }
    }
    if (event.getEventId() != curentCommandId) {
      throw new IllegalStateException(
          "Command eventId " + curentCommandId + " doesn't match eventId: " + event.getEventId());
    }
    Command command = newCommand.getCommand();
    validateCommand(command, event);
    commands.put(curentCommandId, newCommand.getCommands());
    System.out.println(" takeCommand commands.put " + curentCommandId + ", command=" + command);
    curentCommandId++;
  }

  /** Validates that command matches the event during replay. */
  private void validateCommand(Command command, HistoryEvent event) {
    if (!equals(command.getCommandType(), event.getEventType())) {
      throw new IllegalStateException(command + " doesn't match " + event);
    }
  }

  /**
   * Compares command to its correpsonding event.
   *
   * @return true if matches
   */
  private boolean equals(CommandType commandType, EventType eventType) {
    return getEventTypeForCommand(commandType) == eventType;
  }

  public List<Command> takeCommands() {
    System.out.println("TAKE COMMANDS");
    List<Command> result = new ArrayList<>(preparedCommands.size());
    // Account for workflow task completed
    long commandEventId = startedEventId + 2;
    for (NewCommand newCommand : preparedCommands) {
      if (newCommand.isCanceled()) {
        throw new IllegalStateException("Canceled command: " + newCommand.getCommand());
      }
      Command command = newCommand.getCommand();
      result.add(command);
      System.out.println("TAKE COMMANDS put " + commandEventId + ": " + command);
      commands.put(commandEventId, newCommand.getCommands());
      commandEventId++;
      newCommand.setInitialCommandEventId(commandEventId);
    }
    preparedCommands.clear();
    return result;
  }

  private void prepareCommands() {
    System.out.println("PREPARE COMMANDS");
    preparedCommands = new ArrayList<>(newCommands.size());
    // Account for workflow task completed
    long commandEventId = startedEventId + 2;
    while (true) {
      NewCommand newCommand = newCommands.poll();
      if (newCommand == null) {
        break;
      }
      if (!newCommand.isCanceled()) {
        preparedCommands.add(newCommand);
      }
      newCommand.getCommands().handleCommand(newCommand.getCommandType());
    }
  }

  /**
   * @param attributes attributes used to schedule an activity
   * @param completionCallback one of ActivityTaskCompletedEvent, ActivityTaskFailedEvent,
   *     ActivityTaskTimedOutEvent, ActivityTaskCanceledEvents
   * @return an instance of ActivityCommands
   */
  public ActivityCommands newActivity(
      ScheduleActivityTaskCommandAttributes attributes,
      Functions.Proc1<HistoryEvent> completionCallback) {
    return ActivityCommands.newInstance(attributes, completionCallback, sink);
  }

  /**
   * Creates a new timer state machine
   *
   * @param attributes timer command attributes
   * @param completionCallback invoked when timer fires or reports cancellation. One of
   *     TimerFiredEvent, TimerCanceledEvent.
   * @return cancellation callback that should be invoked to initiate timer cancellation
   */
  public Functions.Proc newTimer(
      StartTimerCommandAttributes attributes, Functions.Proc1<HistoryEvent> completionCallback) {
    System.out.println("newTimer");
    TimerCommands timer = TimerCommands.newInstance(attributes, completionCallback, sink);
    return () -> timer.cancel();
  }

  /**
   * Creates a new child state machine
   *
   * @param attributes child workflow start command attributes
   * @param startedCallback callback that is notified about child start
   * @param completionCallback invoked when child reports completion or failure. The following types
   *     of events can be passed to the callback: StartChildWorkflowExecutionFailedEvent,
   *     ChildWorkflowExecutionCompletedEvent, ChildWorkflowExecutionFailedEvent,
   *     ChildWorkflowExecutionTimedOutEvent, ChildWorkflowExecutionCanceledEvent,
   *     ChildWorkflowExecutionTerminatedEvent.
   * @return cancellation callback that should be invoked to cancel the child
   */
  public Functions.Proc1<ChildWorkflowCancellationType> newChildWorkflow(
      StartChildWorkflowExecutionCommandAttributes attributes,
      Functions.Proc1<WorkflowExecution> startedCallback,
      Functions.Proc1<HistoryEvent> completionCallback) {
    ChildWorkflowCommands child =
        ChildWorkflowCommands.newInstance(attributes, startedCallback, completionCallback, sink);
    return (cancellationType) -> {
      // The only time child can be cancelled directly is before its start command
      // was sent out to the service. After that RequestCancelExternal should be used.
      if (child.isCancellable()) {
        if (cancellationType == ChildWorkflowCancellationType.ABANDON) {
          notifyChildCancelled(attributes, completionCallback);
          return;
        }
        child.cancel();
      } else if (!child.isFinalState()) {
        if (cancellationType == ChildWorkflowCancellationType.ABANDON) {
          notifyChildCancelled(attributes, completionCallback);
          return;
        }
        newCancelExternal(
            RequestCancelExternalWorkflowExecutionCommandAttributes.newBuilder()
                .setWorkflowId(attributes.getWorkflowId())
                .setNamespace(attributes.getNamespace())
                .build(),
            (event) -> {
              if (cancellationType == ChildWorkflowCancellationType.WAIT_CANCELLATION_REQUESTED) {
                notifyChildCancelled(attributes, completionCallback);
              }
            });
        if (cancellationType == ChildWorkflowCancellationType.TRY_CANCEL) {
          notifyChildCancelled(attributes, completionCallback);
        }
      }
    };
  }

  private static void notifyChildCancelled(
      StartChildWorkflowExecutionCommandAttributes attributes,
      Functions.Proc1<HistoryEvent> completionCallback) {
    completionCallback.apply(
        HistoryEvent.newBuilder()
            .setEventType(EventType.EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED)
            .setChildWorkflowExecutionCanceledEventAttributes(
                ChildWorkflowExecutionCanceledEventAttributes.newBuilder()
                    .setWorkflowType(attributes.getWorkflowType())
                    .setNamespace(attributes.getNamespace())
                    .setWorkflowExecution(
                        WorkflowExecution.newBuilder().setWorkflowId(attributes.getWorkflowId())))
            .build());
  }

  /**
   * @param attributes
   * @param completionCallback invoked when signal delivery completes of fails. The following types
   *     of events can be passed to the callback: ExternalWorkflowExecutionSignaledEvent,
   *     SignalExternalWorkflowExecutionFailedEvent>
   */
  public Functions.Proc newSignalExternal(
      SignalExternalWorkflowExecutionCommandAttributes attributes,
      Functions.Proc2<HistoryEvent, Boolean> completionCallback) {
    return SignalExternalCommands.newInstance(attributes, completionCallback, sink);
  }

  /**
   * @param attributes attributes to use to cancel external worklfow
   * @param completionCallback one of ExternalWorkflowExecutionCancelRequestedEvent,
   *     RequestCancelExternalWorkflowExecutionFailedEvent
   */
  public void newCancelExternal(
      RequestCancelExternalWorkflowExecutionCommandAttributes attributes,
      Functions.Proc1<HistoryEvent> completionCallback) {
    CancelExternalCommands.newInstance(attributes, completionCallback, sink);
  }

  public void newUpsertSearchAttributes(
      UpsertWorkflowSearchAttributesCommandAttributes attributes) {
    UpsertSearchAttributesCommands.newInstance(attributes, sink);
  }

  public void newCompleteWorkflow(Optional<Payloads> workflowOutput) {
    CompleteWorkflowCommands.newInstance(workflowOutput, sink);
  }

  public void newFailWorkflow(Failure failure) {
    FailWorkflowCommands.newInstance(failure, sink);
  }

  public void newCancelWorkflow() {
    CancelWorkflowCommands.newInstance(
        CancelWorkflowExecutionCommandAttributes.getDefaultInstance(), sink);
  }

  public void newContinueAsNewWorkflow(ContinueAsNewWorkflowExecutionCommandAttributes attributes) {
    ContinueAsNewWorkflowCommands.newInstance(attributes, sink);
  }

  public boolean isReplaying() {
    return previousStartedEventId >= startedEventId;
  }

  public long currentTimeMillis() {
    return currentTimeMillis;
  }

  public UUID randomUUID() {
    String runId = currentRunId;
    if (runId == null) {
      throw new Error("null currentRunId");
    }
    String id = runId + ":" + idCounter++;
    byte[] bytes = id.getBytes(StandardCharsets.UTF_8);
    return UUID.nameUUIDFromBytes(bytes);
  }

  public Random newRandom() {
    return new Random(randomUUID().getLeastSignificantBits());
  }

  public void sideEffect(
      Functions.Func<Optional<Payloads>> func,
      Functions.Proc2<Optional<Payloads>, RuntimeException> callback) {
    SideEffectMarkerCommands.newInstance(
        isReplaying() ? null : func,
        (payloads, exception) -> {
          callback.apply(payloads, exception);
          // callback unblocked sideEffect call. Give workflow code chance to make progress.
          callbacks.eventLoop();
        },
        sink);
  }

  /**
   * @param id mutable side effect id
   * @param func given the value from the last marker returns value to store. If result is empty
   *     nothing is recorded into the history.
   * @param callback used to report result or failure
   */
  public void mutableSideEffect(
      String id,
      Functions.Func1<Optional<Payloads>, Optional<Payloads>> func,
      Functions.Proc2<Optional<Payloads>, RuntimeException> callback) {
    //    Optional<Payloads> result;
    //    RecordMarkerCommandAttributes markerAttributes;
    //    // Call func only the first time
    //    if (isReplaying()) {
    //      markerAttributes = RecordMarkerCommandAttributes.getDefaultInstance();
    //      result = null;
    //    } else {
    //      try {
    //        Optional<Payloads> toStore = func.apply(stored);
    //        if (toStore.isPresent()) {}
    //      } catch (RuntimeException e) {
    //        callback.apply(Optional.empty(), e);
    //        return;
    //      }
    //      Map<String, Payloads> details = new HashMap<>();
    //      if (result.isPresent()) {
    //        details.put(MARKER_DATA_KEY, result.get());
    //      }
    //      markerAttributes =
    //          RecordMarkerCommandAttributes.newBuilder()
    //              .setMarkerName(SIDE_EFFECT_MARKER_NAME)
    //              .putAllDetails(details)
    //              .build();
    //    }
    //    final Optional<Payloads> finalResult = result; // cannot reference result directly from
    // lambda
    //    System.out.println("SideEffect called");
    //    MarkerCommands.newInstance(
    //        markerAttributes,
    //        (event -> {
    //          // Event is null when callback is called during initial execution (non replay).
    //          if (event == null) {
    //            callback.apply(finalResult, null);
    //          } else {
    //            MarkerRecordedEventAttributes attributes =
    // event.getMarkerRecordedEventAttributes();
    //            if (!attributes.getMarkerName().equals(SIDE_EFFECT_MARKER_NAME)) {
    //              throw new IllegalStateException(
    //                  "Expected " + SIDE_EFFECT_MARKER_NAME + ", received: " + attributes);
    //            }
    //            Map<String, Payloads> map = attributes.getDetailsMap();
    //            Optional<Payloads> fromMaker = Optional.ofNullable(map.get(MARKER_DATA_KEY));
    //            callback.apply(fromMaker, null);
    //          }
    //          // callback unblocked sideEffect call. Give workflow code chance to make progress.
    //          callbacks.eventLoop();
    //        }),
    //        sink);
  }

  private class WorkflowTaskCommandsListener implements WorkflowTaskCommands.Listener {
    @Override
    public void workflowTaskStarted(long startedEventId, long currentTimeMillis) {
      setStartedEventId(startedEventId);
      setCurrentTimeMillis(currentTimeMillis);
      CommandsManager.this.callbacks.eventLoop();
      if (CommandsManager.this.workflowTaskStartedEventId == startedEventId) {
        prepareCommands();
      }
    }

    @Override
    public void updateRunId(String currentRunId) {
      CommandsManager.this.currentRunId = currentRunId;
    }
  }

  private long getInitialCommandEventId(HistoryEvent event) {
    switch (event.getEventType()) {
      case EVENT_TYPE_ACTIVITY_TASK_STARTED:
        return event.getActivityTaskStartedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_COMPLETED:
        return event.getActivityTaskCompletedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_FAILED:
        return event.getActivityTaskFailedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_TIMED_OUT:
        return event.getActivityTaskTimedOutEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_CANCEL_REQUESTED:
        return event.getActivityTaskCancelRequestedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_REQUEST_CANCEL_ACTIVITY_TASK_FAILED:
        throw new IllegalArgumentException("Unexpected event type: " + event.getEventType());
      case EVENT_TYPE_ACTIVITY_TASK_CANCELED:
        return event.getActivityTaskCanceledEventAttributes().getScheduledEventId();
      case EVENT_TYPE_TIMER_FIRED:
        return event.getTimerFiredEventAttributes().getStartedEventId();
      case EVENT_TYPE_CANCEL_TIMER_FAILED:
        throw new IllegalArgumentException("Unexpected event type: " + event.getEventType());
      case EVENT_TYPE_TIMER_CANCELED:
        return event.getTimerCanceledEventAttributes().getStartedEventId();
      case EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
        return event
            .getRequestCancelExternalWorkflowExecutionFailedEventAttributes()
            .getInitiatedEventId();
      case EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
        return event
            .getExternalWorkflowExecutionCancelRequestedEventAttributes()
            .getInitiatedEventId();
      case EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_FAILED:
        return event.getStartChildWorkflowExecutionFailedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_STARTED:
        return event.getChildWorkflowExecutionStartedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_COMPLETED:
        return event.getChildWorkflowExecutionCompletedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_FAILED:
        return event.getChildWorkflowExecutionFailedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_CANCELED:
        return event.getChildWorkflowExecutionCanceledEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TIMED_OUT:
        return event.getChildWorkflowExecutionTimedOutEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_CHILD_WORKFLOW_EXECUTION_TERMINATED:
        return event.getChildWorkflowExecutionTerminatedEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_FAILED:
        return event
            .getSignalExternalWorkflowExecutionFailedEventAttributes()
            .getInitiatedEventId();
      case EVENT_TYPE_EXTERNAL_WORKFLOW_EXECUTION_SIGNALED:
        return event.getExternalWorkflowExecutionSignaledEventAttributes().getInitiatedEventId();
      case EVENT_TYPE_WORKFLOW_TASK_STARTED:
        return event.getWorkflowTaskStartedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_WORKFLOW_TASK_COMPLETED:
        return event.getWorkflowTaskCompletedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_WORKFLOW_TASK_TIMED_OUT:
        return event.getWorkflowTaskTimedOutEventAttributes().getScheduledEventId();
      case EVENT_TYPE_WORKFLOW_TASK_FAILED:
        return event.getWorkflowTaskFailedEventAttributes().getScheduledEventId();
      case EVENT_TYPE_ACTIVITY_TASK_SCHEDULED:
      case EVENT_TYPE_TIMER_STARTED:
      case EVENT_TYPE_MARKER_RECORDED:
      case EVENT_TYPE_SIGNAL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_START_CHILD_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_REQUEST_CANCEL_EXTERNAL_WORKFLOW_EXECUTION_INITIATED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CONTINUED_AS_NEW:
      case EVENT_TYPE_WORKFLOW_EXECUTION_TERMINATED:
      case EVENT_TYPE_UPSERT_WORKFLOW_SEARCH_ATTRIBUTES:
      case EVENT_TYPE_WORKFLOW_TASK_SCHEDULED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_SIGNALED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_STARTED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_COMPLETED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_FAILED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_TIMED_OUT:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCEL_REQUESTED:
      case EVENT_TYPE_WORKFLOW_EXECUTION_CANCELED:
        return event.getEventId();
      case UNRECOGNIZED:
      case EVENT_TYPE_UNSPECIFIED:
        throw new IllegalArgumentException("Unexpected event type: " + event.getEventType());
    }
    throw new IllegalStateException("unreachable");
  }
}
